from pandas import DataFrame
from main.первичная_обработка import СырыеДанные
from numpy import NaN


def get_from_dataframe(data, loc_x, loc_y):
    try:
        x = data.loc[loc_x, loc_y]
    # Надо бы разобраться с типом исключения
    # И нужен ли вообще тут тип исключения
    except:
        x = 0
    return x


def isnan(num):
    if type(num) == str:
        raise ValueError("isnan применено к строке")
    return num != num


def обработка_доп_данных(данные):
    if type(данные) == str:
        возврат = данные.split(", ")
    else:
        if данные != данные:
            возврат = 0
        else:
            возврат = данные
    return возврат


def проверка_строка(строка):
    if type(строка) != str:
        raise ValueError("Не является строкой")


class ДанныеДляПроверки:
    """Класс для получения данных из таблицы в формате обрабатываемом \
    классом проверки исходных данных.
    При создании передаются метки, при вызове передаются сами данные и \
    производится расчет."""

    @staticmethod
    def проверка_данные(data):
        if type(data) != СырыеДанные:
            raise ValueError("Не является экземпляром класса СырыеДанные")

    @staticmethod
    def составление_списка(data, метка_список):
        список_узлов = []
        метка = data.keys[метка_список][0].copy()
        метка[0] += 1  # Переходим от метки к первому узлу
        while метка[0] < data.height and \
                data.data.iloc[метка[0], метка[1]] is not NaN:
            список_узлов.append({"название узла":
                                data.data.iloc[метка[0], метка[1]],
                                 "Количество":
                                 data.data.iloc[метка[0], метка[1]+1]})
            метка[0] += 1
        return список_узлов

    @staticmethod
    def проверка_узлов(data, метка_узел):
        лист_узлов = []
        лист_имен_узлов = []
        лист_доп_инф = []
        обр_доп_инф = []
        номер_узла = -1
        for glass in data.keys[метка_узел]:
            номер_узла += 1
            лист_узлов.append(DataFrame())
            метка = glass.copy()
            лист_имен_узлов.append((data.data.iloc[метка[0]-1,
                                                   метка[1]-1]))
            лист_доп_инф.append((data.data.iloc[метка[0], метка[1]-1]))
            обр_доп_инф.append(обработка_доп_данных(
                data.data.iloc[метка[0], метка[1] - 1]))
            метка[0] += 1
            while (метка[0] < data.height
                   and data.data.iloc[метка[0], метка[1]-1] is not NaN):
                лист_узлов[номер_узла].loc[data.data.iloc[метка[0],
                                                          метка[1] - 1],
                                           "количество"] = (
                    data.data.iloc[метка[0], метка[1]]
                )
                if метка[1]+1 < data.breadth:
                    лист_узлов[номер_узла].loc[data.data.iloc[метка[0],
                                                              метка[1] - 1],
                                               "множитель"] = (
                        data.data.iloc[метка[0], метка[1]+1]
                    )
                else:
                    лист_узлов[номер_узла].loc[data.data.iloc[метка[0],
                                                              метка[1] - 1],
                                               "множитель"] = 1
                метка[0] += 1
        for узел in лист_узлов:
            for glass in узел.index:
                if isnan(узел.loc[glass, "множитель"]):
                    узел.loc[glass, "множитель"] = 1
        возврат = []
        for x in range(len(лист_узлов)):
            возврат.append({"Название": лист_имен_узлов[x],
                            "Доп.инф.": лист_доп_инф[x],
                            "Обр.доп.инф.": обр_доп_инф[x],
                            "Узел": лист_узлов[x]})
        return возврат

    def __init__(self, метка_список, метка_узел, метка_вложенный_узел=None):
        проверка_строка(метка_список)
        проверка_строка(метка_узел)
        проверка_строка(метка_вложенный_узел)
        self._метка_список = метка_список
        self._метка_узел = метка_узел
        self._метка_ву = метка_вложенный_узел

    def __call__(self, data):
        self.проверка_данные(data)
        self._количество_узлов = self.составление_списка(data,
                                                         self._метка_список)
        self._узлы = self.проверка_узлов(data, self._метка_узел)
        self._подузлы = self.проверка_узлов(data, self._метка_ву)

    @property
    def количество_узлов(self):
        return self._количество_узлов

    @property
    def узлы(self):
        return self._узлы

    @property
    def подузлы(self):
        return self._подузлы


class Узлы:

    @staticmethod
    def проверка_данные(data):
        if type(data) != СырыеДанные:
            raise ValueError("Не является экземпляром класса СырыеДанные")

    @staticmethod
    def nan_to_1(something):
        if isnan(something):
            return 1
        else:
            return something

    @staticmethod
    def составление_списка(data, метка_список):
        список_узлов = {}
        метка = data.keys[метка_список][0].copy()
        метка[0] += 1  # Переходим от метки к первому узлу
        while метка[0] < data.height and \
                data.data.iloc[метка[0], метка[1]] is not NaN:
            список_узлов[data.data.iloc[метка[0], метка[1]]] = (
                data.data.iloc[метка[0], метка[1]+1]
            )
            метка[0] += 1
        return список_узлов

    def составление_узлов(self, data, метка_узел):
        узлы = {}
        for glass in data.keys[метка_узел]:
            метка = glass.copy()
            название = data.data.iloc[glass[0]-1, glass[1]-1]
            узлы[название] = {}
            узлы[название]["узел"] = (
                DataFrame()
            )
            узлы[название]["инфо"] = (
                обработка_доп_данных(data.data.iloc[метка[0],
                                                    метка[1]-1])
            )
            метка[0] += 1
            while (метка[0] < data.height
                   and data.data.iloc[метка[0], метка[1]-1] is not NaN):
                узлы[название]["узел"].loc[data.data.iloc[метка[0],
                                                          метка[1] - 1],
                                           "количество"] = (
                    data.data.iloc[метка[0], метка[1]]
                )
                if метка[1]+1 < data.breadth:
                    узлы[название]["узел"].loc[data.data.iloc[метка[0],
                                                              метка[1] - 1],
                                               "множитель"] = self.nan_to_1(
                        data.data.iloc[метка[0], метка[1]+1]
                    )
                else:
                    узлы[название]["узел"].loc[data.data.iloc[метка[0],
                                                              метка[1] - 1],
                                               "множитель"] = 1
                метка[0] += 1
        return узлы

    def поиск_макс_подузла(self):
        x = 0
        for подузел in self._подузлы.keys():
            if x < self._подузлы[подузел]["инфо"]:
                x = self._подузлы[подузел]["инфо"]
        return x

    def списки_узлов_по_инфо(self, макс_число):
        список_по_инфо = []
        подузлы = {}
        for k in self._подузлы.keys():
            подузлы[k] = 1
        for number in range(макс_число+1):
            список_по_инфо.append([])
            копия_подузлы = подузлы.copy()
            for k in копия_подузлы.keys():
                if self._подузлы[k]["инфо"] == number:
                    список_по_инфо[number].append(k)
                    del подузлы[k]
        return список_по_инфо

    def добавление_подузла(self, k, узел):
        количество = self._узлы[узел]["узел"].loc[k, "количество"]
        множитель = self._узлы[узел]["узел"].loc[k, "множитель"]
        if isnan(множитель):
            множитель = 1
        количество = количество * множитель
        self._узлы[узел]["узел"].drop(index=k, inplace=True)
        for key in self._подузлы[k]["узел"].index:
            self._узлы[узел]["узел"].loc[key, "количество"] = (
                self._подузлы[k]["узел"].loc[key, "количество"] *
                количество +
                get_from_dataframe(self._узлы[узел]["узел"], key,
                                   "количество")
            )
            if isnan(self._узлы[узел]["узел"].loc[key, "множитель"]):
                self._узлы[узел]["узел"].loc[key, "множитель"] = (
                    self._подузлы[k]["узел"].loc[key, "множитель"])
            elif self._узлы[узел]["узел"].loc[key, "множитель"] == (
                 self._подузлы[k]["узел"].loc[key, "множитель"]):
                self._узлы[узел]["узел"].loc[key, "множитель"] = (
                    self._подузлы[k]["узел"].loc[key, "множитель"])
            else:
                количество1 = (self._узлы[узел]["узел"].loc[key,
                                                            "количество"] -
                               self._подузлы[k]["узел"].loc[key,
                                                            "количество"])
                множитель1 = self._узлы[узел]["узел"].loc[key,
                                                          "множитель"]
                количество2 = self._подузлы[k]["узел"].loc[key,
                                                           "количество"]
                множитель2 = self._подузлы[k]["узел"].loc[key,
                                                          "множитель"]
                self._узлы[узел]["узел"].loc[key, "множитель"] = (
                    (количество1 * множитель1 + количество2 * множитель2) /
                    (количество1 + количество2))

    def добавление_подузлов(self):
        макс_число = self.поиск_макс_подузла()
        по_инфо = self.списки_узлов_по_инфо(макс_число)
        for number in range(макс_число+1):
            for k in по_инфо[number]:
                for узел in self._узлы.keys():
                    if k in self._узлы[узел]["узел"].index:
                        self.добавление_подузла(k, узел)

    def __init__(self, метка_список, метка_узел, метка_вложенный_узел=None):
        проверка_строка(метка_список)
        проверка_строка(метка_узел)
        проверка_строка(метка_вложенный_узел)
        self._метка_список = метка_список
        self._метка_узел = метка_узел
        self._метка_ву = метка_вложенный_узел

    def __call__(self, data):
        self.проверка_данные(data)
        self._список_узлов = self.составление_списка(data,
                                                     self._метка_список)
        self._узлы = self.составление_узлов(data, self._метка_узел)
        self._подузлы = self.составление_узлов(data, self._метка_ву)
        self.добавление_подузлов()

    @property
    def список_узлов(self):
        return self._список_узлов

    @property
    def узлы(self):
        return self._узлы

    @property
    def подузлы(self):
        return self._подузлы
